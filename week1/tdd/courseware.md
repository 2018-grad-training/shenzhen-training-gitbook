# 课件

这其实是一份讲课大纲。

## 讲课大纲

* 什么是 TDD - 这节主要讲理论，花大概 3-5 分钟。主要目的：让学生觉得 TDD 是正确的、不得不做的事情。
  * 先写测试，后写实现的开发方式
  * 有没有发现，Tasking 还没有回答一个问题。它回答了「做完什么算做完」这个问题，让你知道应该做什么。但它回答不了的问题是，「怎么知道你做完了」没有呢？我怎么验收呢？你说我做完了，那么为什么 QA 不相信你呢？十几乃至几十年来软件工程用的方式是开发手动自测+测试部门测试。这种方式，也不说 low，但它有很多问题解决不了，比如部门墙、不能自动化回归、缓慢的响应速度，对于互联网时代快速增长、变化的业务需求已经显得笨重了，这就是我们说的「组织响应力」太慢。我们需要更现代的开发理念和实践来解决这个问题。所以，大家在现代了，要用更先进的方式来解决问题了。现代的方式是什么呢？TDD 是其中一个重要的基石
  * 测试先行——我们讲的测试是可以自动化运行的——就是用自动化的方式，来回答「我做完了」这个问题。自动化的测试顺便还能做回归用，为老功能保驾护航，实际上是提升了应用整体的响应力
* TDD 的好处
  * 测试可以自动化地、可靠地回答「你是否做完了」这个问题
  * 利于回归和重构 - 没有测试的项目只能腐化
  * 小步前进、终结调试
  * 测试即文档
  * 信心
* 如何做 TDD
  1.  三原则：
      * 没有红的测试不写代码（也就是先写测试。因为没有红的测试，说明你没有需要验收的东西嘛；如果你写了代码但没有测试，那就说明它们没法被自动化验收嘛；这也是 TDD 神教的口号）
      * 只允许编写刚好能使实现挂掉的测试代码（很好，小步前进，防止你一次实现太多）
      * 只允许编写刚好能使测试通过的产品代码（我认为这点可以根据能力和对需求可能变化点的经验灵活掌握，是否可以不用在课上过多强调这点）
  2.  tasking - 测试用例（想想如何验收你的 tasking） - 因此例子要尽量使用没有 GUI 的
  3.  红绿-重构循环
  4.  前端测试框架讲解、如何实际上手：引出 jest 和断言语法、测试的三段式、好测试的特征
* 例子演练 I：FizzBuzz - 这步操练到 tasking 和测试用例
* 什么时候进行重构？重构的定义是什么？没有测试叫不叫重构？重构的目标是什么——整洁代码、DRY 的代码、SRP 的代码、易于可预见的扩展。重构要基于事实来，不要臆想，扎实地进行合理的需求预测
* 例子演练 II：重构 FizzBuzz？ - 这步操练到重构相关。可以引入一下重构相关的东西。不过，重构分出第二步来讲，会不会给学生一种印象 - 重构不在红绿循环之内？另外是，可以加需求，让他们意识到重复的点在面对需求变更时需要的修改，从而有目的地对变化点进行抽象重构，而不是基于臆想。不过，这样的话，是不是就需要真实的例子？
* 测试金字塔
* stub & mock - 什么时候讲？FizzBuzz 里不会遇到
* 例子演练 III ：POS 机 - 涉及 mock 和 stub
* TDD 的缺点 - 什么场景不适合用 TDD
  * 前端少不了 UI 怎么办？

## 验收标准

* 会不会做 TDD 的先写测试，后写简单实现，然后重构——安排课堂练习；轮流上去做？课后作业；
* 会不会重构：识别出坏味道，在有测试保障的情况下重构代码——安排课堂练习；轮流上去做；课后作业；
* 会不会小步提交：一次写一个测试、实现、重构，不行了马上 checkout 代码或简单实现重新来——怎么验收？
* 是否掌握了测试金字塔——怎么验收？
* 是否掌握了 mock/stub 技术——安排课堂练习
* 是否了解 TDD 的缺点——怎么验收？

所以总结下来，需要安排三个练习：

1.  基本的 TDD 练习，需要很简单，没有 mock，没有 UI，不需要重构也可以完成作业
2.  重构的练习。就在原来的例子上加以重构
3.  含有 mock 技术的 TDD 练习（但不要涉及控制台以外的 UI）

初步的想法是，1、2 个例子使用 FizzBuzz，第 3 个例子使用 POS 机。

